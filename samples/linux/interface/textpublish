    // loop and publish
	while((NETWORK_ATTEMPTING_RECONNECT == rc || NETWORK_RECONNECTED == rc || SUCCESS == rc)
		  && (publishCount > 0 || infinitePublishFlag)) {

		//Max time the yield function will wait for read messages
		rc = aws_iot_mqtt_yield(&mqttClient, 100);
		if(NETWORK_ATTEMPTING_RECONNECT == rc) {
			// If the client is attempting to reconnect we will skip the rest of the loop.
			continue;
		}

		sleep(1);

        sprintf(cPayload,"%s%d%s", "{\"Firma\": \"Hardkernel\", \"Sensor\": \"Odroid-C2\", \"Messwert\": \"", i++, "\"}");
		msg.payloadLen = strlen(cPayload);
        printf("%s %s%s %zu %s\n", "Payload length topic", topicHardwareInfo, ":", strlen(cPayload), "Byte");
		rc = aws_iot_mqtt_publish(&mqttClient, topicHardwareInfo, topicHardwareInfoLen, &msg);


        sprintf(cPayload,"%s", getMemInfo(memInfo));
		msg.payloadLen = strlen(cPayload);
        printf("%s %s%s %zu %s\n", "Payload length topic", topicMemInfo, ":", strlen(cPayload), "Byte");
        rc = aws_iot_mqtt_publish(&mqttClient, topicMemInfo, topicMemInfoLen, &msg);

        printf("%s %zu %s\n\n", "Max payload length each topic:", sizeof(cPayload), "Byte");


        /*
        if (rc == MQTT_REQUEST_TIMEOUT_ERROR) {
			IOT_WARN("QOS1 publish ack not received.\n");
			rc = SUCCESS;
		}*/
        /**
		if(publishCount > 0) {
			publishCount--;
		}*/

	}

	if(SUCCESS != rc) {
		IOT_ERROR("An error occurred in the loop.\n");
	} else {
		IOT_INFO("Publish done\n");
	}